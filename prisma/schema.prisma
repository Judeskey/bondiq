generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum CoupleStatus {
  ACTIVE
  PAUSED
}

enum LoveLanguage {
  WORDS
  TIME
  GIFTS
  SERVICE
  TOUCH
}

enum ToneMode {
  ANALYTICAL
  WARM
  CALM
  STRATEGIC
}

enum PlanType {
  FREE
  PREMIUM
}

enum EmotionState {
  THRIVING
  GOOD
  NEUTRAL
  STRESSED
  DISCONNECTED
}

enum GratitudeVisibility {
  PRIVATE
  SHARED
}

enum VisibilityLevel {
  PRIVATE // only me
  PARTNER // visible to partner (if couple is PRO)
  COUPLE // visible to both (future: shared views)
}

model User {
  id              String  @id @default(cuid())
  email           String  @unique
  name            String?
  image           String?
  profileImageUrl String? // ✅ user-chosen avatar inside BondIQ (stable)
  timezone        String? // ✅ e.g. "America/Toronto"

  emailVerified         DateTime?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  passwordHash          String?
  passwordUpdatedAt     DateTime?
  onboardingStep        Int       @default(1)
  onboardingCompleted   Boolean   @default(false)
  planType              PlanType  @default(FREE)
  proUntil              DateTime?
  planUpdatedAt         DateTime  @default(now())
  weeklyEmailEnabled    Boolean   @default(true)
  weeklyEmailDay        Int       @default(0) // 0=Sunday...6=Saturday (local)
  weeklyEmailTime       String    @default("19:00") // "HH:mm" local time
  weeklyEmailLastSentAt DateTime?

  // Auth.js / NextAuth
  accounts Account[]
  sessions Session[]

  // Resonance
  memberships       CoupleMember[]
  profiles          LoveProfile[]
  checkins          CheckIn[]
  reportViews       WeeklyReportForUser[]
  emotionSignals    PartnerEmotionSignal[]
  gratitudeEntries  GratitudeEntry[]
  aliasesGiven      PartnerAlias[]         @relation("AliasOwner")
  aliasesReceived   PartnerAlias[]         @relation("AliasTarget")
  emotionSnapshots  EmotionStateSnapshot[]
  DisconnectRequest DisconnectRequest[]
  dailyEngagements  DailyEngagement[]
  emailSendLogs     EmailSendLog[]
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Couple {
  id        String       @id @default(cuid())
  status    CoupleStatus @default(ACTIVE)
  reportDay Int          @default(0) // 0=Sunday ... 6=Saturday
  timezone  String       @default("America/Toronto")
  pausedAt  DateTime?
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt

  // ✅ Couple-level subscription entitlements (SOURCE OF TRUTH)
  planType           PlanType  @default(FREE)
  proUntil           DateTime?
  planUpdatedAt      DateTime  @default(now())
  billingOwnerUserId String?
  reportTimeMinutes  Int       @default(540) // 09:00 local time (9*60)
  stripeCustomerId String? @unique

  members                CoupleMember[]
  invites                Invite[]
  profiles               LoveProfile[]
  checkins               CheckIn[]
  weeklyReports          WeeklyReport[]
  subscription           Subscription?
  partnerAliases         PartnerAlias[]
  dailyMetrics           DailyCoupleMetric[]
  emotionSignals         PartnerEmotionSignal[]
  gratitudeEntries       GratitudeEntry[]
  repairSuggestionUsages RepairSuggestionUsage[]
  emotionSnapshots       EmotionStateSnapshot[]
  insightsCache          CoupleInsightsCache[]
  DisconnectRequest      DisconnectRequest[]
}

model CoupleMember {
  id       String   @id @default(cuid())
  coupleId String
  userId   String
  joinedAt DateTime @default(now())

  // ✅ Privacy controls (MVP)
  shareEmotionState VisibilityLevel @default(PARTNER)
  shareTags         VisibilityLevel @default(PARTNER)
  shareCheckinText  VisibilityLevel @default(PRIVATE)
  shareInsights     VisibilityLevel @default(PARTNER)

  couple Couple @relation(fields: [coupleId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([coupleId, userId])
  @@index([userId])
  @@index([coupleId, joinedAt])
}

model Invite {
  id         String    @id @default(cuid())
  coupleId   String
  email      String? // ✅ bind invite to email
  tokenHash  String    @unique
  expiresAt  DateTime
  acceptedAt DateTime?
  createdAt  DateTime  @default(now())

  couple Couple @relation(fields: [coupleId], references: [id], onDelete: Cascade)

  @@index([coupleId])
  @@index([email])
}

model LoveProfile {
  id       String @id @default(cuid())
  coupleId String
  userId   String

  primaryLanguage   LoveLanguage
  secondaryLanguage LoveLanguage?
  tertiaryLanguage  LoveLanguage?

  avoidList       Json?
  expressionStyle Json?
  completedAt     DateTime?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  couple Couple @relation(fields: [coupleId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([coupleId, userId])
  @@index([userId])
}

model CheckIn {
  id String @id @default(cuid())

  coupleId String
  userId   String

  weekStart DateTime

  rating              Int
  whatMadeMeFeelLoved String
  languageTags        String[] @default([])

  createdAt DateTime @default(now())

  couple Couple @relation(fields: [coupleId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([coupleId, weekStart])
  @@index([userId, createdAt])
}

model WeeklyReport {
  id String @id @default(cuid())

  coupleId  String
  weekStart DateTime

  toneIndex  Int  @default(0) // 0..3 (rotates weekly)
  reportJson Json

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  couple  Couple                @relation(fields: [coupleId], references: [id], onDelete: Cascade)
  perUser WeeklyReportForUser[]

  @@unique([coupleId, weekStart])
  @@index([coupleId, weekStart])
}

model WeeklyReportForUser {
  id String @id @default(cuid())

  reportId String
  userId   String

  sectionsJson Json

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  report WeeklyReport @relation(fields: [reportId], references: [id], onDelete: Cascade)
  user   User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([reportId, userId])
  @@index([userId, reportId])
}

model Subscription {
  id                   String    @id @default(cuid())
  coupleId             String    @unique
  plan                 PlanType  @default(FREE)
  stripeCustomerId     String?
  stripeSubscriptionId String?
  status               String?
  currentPeriodEnd     DateTime?
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt

  couple Couple @relation(fields: [coupleId], references: [id], onDelete: Cascade)
}

model PartnerAlias {
  id String @id @default(cuid())

  coupleId     String
  ownerUserId  String // the viewer (you)
  targetUserId String // the partner you’re naming
  nickname     String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  couple Couple @relation(fields: [coupleId], references: [id], onDelete: Cascade)
  owner  User   @relation("AliasOwner", fields: [ownerUserId], references: [id], onDelete: Cascade)
  target User   @relation("AliasTarget", fields: [targetUserId], references: [id], onDelete: Cascade)

  @@unique([coupleId, ownerUserId, targetUserId])
  @@index([ownerUserId])
  @@index([targetUserId])
}

model DailyCoupleMetric {
  id String @id @default(cuid())

  coupleId String
  day      DateTime // normalized to start-of-day in couple timezone

  // scores (0-100) that drive your graph
  bondScore       Int?
  connectionScore Int?
  stabilityScore  Int?

  // raw inputs for insight engine
  checkInCount Int    @default(0)
  avgRating    Float?

  // optional: store tag counts so pattern detection is cheap
  topTags String[] @default([])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  couple Couple @relation(fields: [coupleId], references: [id], onDelete: Cascade)

  @@unique([coupleId, day])
  @@index([coupleId, day])
}

model PartnerEmotionSignal {
  id String @id @default(cuid())

  coupleId String
  userId   String

  day DateTime // normalized to start-of-day in couple timezone

  state     EmotionState
  intensity Int          @default(50) // 0..100 (for animation strength)

  // optional: short explanation to show in UI
  reasonCode String? // e.g. "LOW_RATING", "MIDWEEK_DIP", "NEEDS_TOUCH"
  note       String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  couple Couple @relation(fields: [coupleId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([coupleId, userId, day])
  @@index([coupleId, day])
  @@index([userId, day])
}

model GratitudeEntry {
  id String @id @default(cuid())

  coupleId String
  userId   String

  // who the gratitude is about (often the partner)
  targetUserId String?

  visibility GratitudeVisibility @default(PRIVATE)

  title String?
  body  String

  // used to resurface memories
  pinned           Boolean   @default(false)
  eventDay         DateTime? // optional "memory date" like anniversary moment
  // ✅ ADD THESE (for resurface logic)
  lastResurfacedAt DateTime?
  resurfacedCount  Int       @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  couple Couple @relation(fields: [coupleId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([coupleId, createdAt])
  @@index([userId, createdAt])
  @@index([targetUserId])
  // ✅ optional (helps resurface ordering)
  @@index([coupleId, lastResurfacedAt])
}

model RepairSuggestionUsage {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  coupleId String
  couple   Couple @relation(fields: [coupleId], references: [id], onDelete: Cascade)

  @@index([coupleId, createdAt])
}

model EmotionStateSnapshot {
  id       String @id @default(cuid())
  coupleId String
  userId   String

  dayKey String // "YYYY-MM-DD" UTC

  state      String
  confidence Float
  reasons    Json
  metrics    Json

  windowDays Int      @default(14)
  createdAt  DateTime @default(now())

  couple Couple @relation(fields: [coupleId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([coupleId, userId, dayKey, windowDays])
  @@index([coupleId, createdAt])
  @@index([userId, createdAt])
  @@index([coupleId, userId, createdAt])
}

model CoupleInsightsCache {
  id String @id @default(cuid())

  coupleId   String
  dayKey     String // "YYYY-MM-DD" UTC
  windowDays Int    @default(28)

  payload   Json
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  couple Couple @relation(fields: [coupleId], references: [id], onDelete: Cascade)

  @@unique([coupleId, dayKey, windowDays])
  @@index([coupleId, updatedAt])
}

model DisconnectRequest {
  id              String   @id @default(cuid())
  coupleId        String
  requesterUserId String

  // sha256(token) stored (never store raw token)
  confirmHash     String   @unique

  // Strong guardrail: user must type this exact phrase
  phrase          String

  // Guardrail: confirmation should expire (e.g. 15 minutes)
  expiresAt       DateTime

  createdAt       DateTime @default(now())
  confirmedAt     DateTime?
  cancelledAt     DateTime?

  couple          Couple   @relation(fields: [coupleId], references: [id], onDelete: Cascade)
  requester       User     @relation(fields: [requesterUserId], references: [id], onDelete: Cascade)

  @@index([coupleId])
  @@index([requesterUserId])
  @@index([expiresAt])
}


model DailyEngagement {
  id                String   @id @default(cuid())
  userId            String
  day               DateTime
  reportViewSeconds Int      @default(0)
  updatedAt         DateTime @updatedAt
  createdAt         DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, day])
  @@index([day])
}

model EmailSendLog {
  id        String   @id @default(cuid())
  userId    String
  type      String // "WEEKLY_REFLECTION"
  dayKey    String // "YYYY-MM-DD" in couple timezone
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, type, dayKey])
  @@index([type, dayKey])
}
model LandingExperimentStat {
  variant      String   @id // "A" | "B" | "C"
  impressions  Int      @default(0)
  clicks       Int      @default(0)
  signInClicks Int      @default(0)
  openAppClicks Int     @default(0)
  updatedAt    DateTime @updatedAt
}

